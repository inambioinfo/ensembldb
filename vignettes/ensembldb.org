#+TITLE: Generating and using Ensembl-based annotation packages
#+AUTHOR:    Johannes Rainer
#+EMAIL:     johannes.rainer@eurac.edu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: header-args :exports code
#+PROPERTY: header-args:R :session *R*

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+BEGIN_EXPORT html
---
title: "Generating an using Ensembl based annotation packages"
author: "Johannes Rainer"
graphics: yes
package: ensembldb
output:
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Generating an using Ensembl based annotation packages}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{ensembldb,EnsDb.Hsapiens.v86,BiocStyle,AnnotationHub,ggbio,Gviz,magrittr}
---

#+END_EXPORT

#+NAME: biocstyle
#+BEGIN_SRC R :ravel echo = FALSE, results = "asis", message = FALSE
  library(BiocStyle)
  BiocStyle::markdown()
#+END_SRC

* How to export this to a =Rnw= vignette			   :noexport:

Use =ox-ravel= from the =orgmode-accessories= package to export this file to a =Rnw= file. After export edit the generated =Rnw= in the following way:

1) Delete all =\usepackage= commands.
2) Move the =<<style>>= code chunk before the =\begin{document}= and before =\author=.
3) Move all =%\Vignette...= lines at the start of the file (even before =\documentclass=).
4) Replace =\date= with =\date{Modified: 21 October, 2013. Compiled: \today}=
5) Eventually search for all problems with =texttt=, i.e. search for pattern ="==.

Note: use =:ravel= followed by the properties for the code chunk headers, e.g. =:ravel results='hide'=. Other options for knitr style options are:
+ =results=: ='hide'= (hides all output, not warnings or messages), ='asis'=, ='markup'= (the default).
+ =warning=: =TRUE= or =FALSE= whether warnings should be displayed.
+ =message=: =TRUE= or =FALSE=, same as above.
+ =include=: =TRUE= or =FALSE=, whether the output should be included into the final document (code is still evaluated).

* How to export this to a =Rmd= vignette			   :noexport:

Use =ox-ravel= to export this file as an R markdown file (=C-c C-e m
r=). That way we don't need to edit the resulting =Rmd= file.

* Introduction

The =ensembldb= package provides functions to create and use transcript centric
annotation databases/packages. The annotation for the databases are directly
fetched from Ensembl [fn:1] using their Perl API. The functionality and data is
similar to that of the =TxDb= packages from the =GenomicFeatures= package, but, in
addition to retrieve all gene/transcript models and annotations from the
database, the =ensembldb= package provides also a filter framework allowing to
retrieve annotations for specific entries like genes encoded on a chromosome
region or transcript models of lincRNA genes. From version 1.7 on, =EnsDb=
databases created by the =ensembldb= package contain also protein annotation data
(see Section [[section.database.layout]] for the database layout and an overview of
available attributes/columns). For more information on the use of the protein
annotations refer to the /proteins/ vignette.

Another main goal of this package is to generate /versioned/ annotation
packages, i.e. annotation packages that are build for a specific Ensembl
release, and are also named according to that (e.g. =EnsDb.Hsapiens.v86= for
human gene definitions of the Ensembl code database version 86). This ensures
reproducibility, as it allows to load annotations from a specific Ensembl
release also if newer versions of annotation packages/releases are available. It
also allows to load multiple annotation packages at the same time in order to
e.g. compare gene models between Ensembl releases.

In the example below we load an Ensembl based annotation package for Homo
sapiens, Ensembl version 86. The =EnsDb= object providing access to the underlying
SQLite database is bound to the variable name =EnsDb.Hsapiens.v86=.

#+NAME: load-libs
#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  library(EnsDb.Hsapiens.v86)

  ## Making a "short cut"
  edb <- EnsDb.Hsapiens.v86
  ## print some informations for this package
  edb

  ## For what organism was the database generated?
  organism(edb)

#+END_SRC


#+NAME: no-network
#+BEGIN_SRC R :results silent :ravel echo = FALSE, results = "hide"
  ## Disable code chunks that require network connection - conditionally
  ## disable this on Windows only. This is to avoid TIMEOUT errors on the
  ## Bioconductor Windows build maching (issue #47).
  use_network <- FALSE

#+END_SRC

* Using =ensembldb= annotation packages to retrieve specific annotations

One of the strengths of the =ensembldb= package and the related =EnsDb= databases is
its implementation of a filter framework that enables to efficiently extract
data sub-sets from the databases. The =ensembldb= package supports most of the
filters defined in the =AnnotationFilter= Bioconductor package and defines some
additional filters specific to the data stored in =EnsDb= databases. Filters can
be passed directly to all methods extracting data from an =EnsDb= (such as =genes=,
=transcripts= or =exons=). Alternatively it is possible with the =addFilter= or =filter=
functions to add a filter directly to an =EnsDb= which will then be used in all
queries on that object.

The =supportedFilters= method can be used to get an overview over all supported
filter classes, each of them (except the =GRangesFilter=) working on a single
column/field in the database.

#+NAME: filters
#+BEGIN_SRC R 
  supportedFilters(edb)

#+END_SRC

These filters can be divided into 3 main filter types:
+ =IntegerFilter=: filter classes extending this basic object can take a single
  numeric value as input and support the conditions /==/, /!=/, />/, /</, />=/ and /<=/. All
  filters that work on chromosomal coordinates, such as the =GeneEndFilter= extend
  =IntegerFilter=.
+ =CharacterFilter=: filter classes extending this object can take a single or
  multiple character values as input and allow conditions: /==/, /!=/, /"startsWith"/
  , /"endsWith"/ and /"contains"/. All filters working on IDs extend this class.
+ =GRangesFilter=: takes a =GRanges= object as input and supports all conditions
  that =findOverlaps= from the =IRanges= package supports ("any", "start", "end",
  "within", "equal"). Note that these have to be passed using the parameter =type=
  to the constructor function.


The supported filters are:
+ =EntrezFilter=: allows to filter results based on NCBI Entrezgene
  identifiers of the genes.
+ =ExonEndFilter=: filter using the chromosomal end coordinate of exons.
+ =ExonIdFilter=: filter based on the (Ensembl) exon identifiers.
+ =ExonRankFilter=: filter based on the rank (index) of an exon within the
  transcript model. Exons are always numbered from 5' to 3' end of the
  transcript, thus, also on the reverse strand, the exon 1 is the most 5' exon
  of the transcript.
+ =ExonStartFilter=: filter using the chromosomal start coordinate of exons.
+ =GeneBiotypeFilter=: filter using the gene biotypes defined in the Ensembl
  database; use the =listGenebiotypes= method to list all available biotypes.
+ =GeneEndFilter=: filter using the chromosomal end coordinate of gene.
+ =GeneIdFilter=: filter based on the Ensembl gene IDs.
+ =GenenameFilter=: filter based on the names (symbols) of the genes.
+ =GeneStartFilter=: filter using the chromosomal start coordinate of gene.
+ =GRangesFilter=: allows to retrieve all features (genes, transcripts or exons)
  that are either within (setting parameter =type= to "within") or partially
  overlapping (setting =type= to "any") the defined genomic region/range. Note
  that, depending on the called method (=genes=, =transcripts= or =exons=) the start
  and end coordinates of either the genes, transcripts or exons are used for the
  filter. For methods =exonsBy=, =cdsBy= and =txBy= the coordinates of =by= are used.
+ =SeqNameFilter=: filter by the name of the chromosomes the genes are encoded
  on.
+ =SeqStrandFilter=: filter for the chromosome strand on which the genes are
  encoded.
+ =SymbolFilter=: filter on gene symbols; note that no database columns /symbol/ is
  available in an =EnsDb= database and hence the gene name is used for filtering.
+ =TxBiotypeFilter=: filter on the transcript biotype defined in Ensembl; use
  the =listTxbiotypes= method to list all available biotypes.
+ =TxEndFilter=: filter using the chromosomal end coordinate of transcripts.
+ =TxIdFilter=: filter on the Ensembl transcript identifiers.
+ =TxNameFilter=: filter on the Ensembl transcript names (currently identical to
  the transcript IDs).
+ =TxStartFilter=: filter using the chromosomal start coordinate of transcripts.

In addition to the above listed /DNA-RNA-based/ filters, /protein-specific/
filters are also available: 

+ =ProtDomIdFilter=: filter by the protein domain ID.
+ =ProteinIdFilter=: filter by Ensembl protein ID filters.
+ =UniprotDbFilter=: filter by the name of the Uniprot database.
+ =UniprotFilter=: filter by the Uniprot ID.
+ =UniprotMappingTypeFilter=: filter by the mapping type of Ensembl protein IDs to
  Uniprot IDs.

These can however only be used on =EnsDb= databases that provide protein
annotations, i.e. for which a call to =hasProteinData= returns =TRUE=.

=EnsDb= databases for more recent Ensembl versions (starting from Ensembl 87)
provide also evidence levels for individual transcripts in the =tx_support_level=
database column. Such databases support also a =TxSupportLevelFilter= filter to
use this columns for filtering.

A simple use case for the filter framework would be to get all transcripts for
the gene /BCL2L11/. To this end we specify a =GenenameFilter= with the value
/BCL2L11/. As a result we get a =GRanges= object with =start=, =end=, =strand= and =seqname=
being the start coordinate, end coordinate, chromosome name and strand for the
respective transcripts. All additional annotations are available as metadata
columns. Alternatively, by setting =return.type= to "DataFrame", or "data.frame"
the method would return a =DataFrame= or =data.frame= object instead of the default
=GRanges=.

#+NAME: transcripts
#+BEGIN_SRC R
  Tx <- transcripts(edb, filter = list(GenenameFilter("BCL2L11")))

  Tx

  ## as this is a GRanges object we can access e.g. the start coordinates with
  head(start(Tx))

  ## or extract the biotype with
  head(Tx$tx_biotype)

#+END_SRC

The parameter =columns= of the extractor methods (such as =exons=, =genes= or
=transcripts)= allows to specify which database attributes (columns) should be
retrieved. The =exons= method returns by default all exon-related columns, the
=transcripts= all columns from the transcript database table and the =genes= all
from the gene table. Note however that in the example above we got also a column
=gene_name= although this column is not present in the transcript database
table. By default the methods return also all columns that are used by any of
the filters submitted with the =filter= argument (thus, because a =GenenameFilter=
was used, the column =gene_name= is also returned). Setting
=returnFilterColumns(edb) <- FALSE= disables this option and only the columns
specified by the =columns= parameter are retrieved.

Instead of passing a filter /object/ to the method it is also possible to provide
a filter /expression/ written as a =formula=. The =formula= has to be written in the
form =~ <field> <condition> <value>= with =<field>= being the field (database
column) in the database, =<condition>= the condition for the filter object and
=<value>= its value. Use the =supportedFilter= method to get the field names
corresponding to each filter class.

#+NAME: transcripts-filter-expression
#+BEGIN_SRC R
  ## Use a filter expression to perform the filtering.
  transcripts(edb, filter = ~ genename == "ZBTB16")

#+END_SRC

Filter expression have to be written as a formula (i.e. starting with a =~=) in
the form /column name/ followed by the logical condition.

Alternatively, =EnsDb= objects can be filtered directly using the =filter=
function. In the example below we use the =filter= function to filter the =EnsDb=
object and pass that filtered database to the =transcripts= method using the =%>%=
from the =magrittr= package.

#+NAME: transcripts-filter
#+BEGIN_SRC R :ravel message = FALSE
  library(magrittr)

  edb %>% filter(~ symbol == "BCL2" & tx_biotype != "protein_coding") %>%
      transcripts

#+END_SRC

Adding a filter to an =EnsDb= enables this filter (globally) on all subsequent
queries on that object. We could thus filter an =EnsDb= to (virtually) contain
only features encoded on chromosome Y.

#+NAME: filter-Y
#+BEGIN_SRC R
  edb_y <- addFilter(edb, SeqNameFilter("Y"))

  ## All subsequent filters on that EnsDb will only work on features encoded on
  ## chromosome Y
  genes(edb_y)

  ## Get all lincRNAs on chromosome Y
  genes(edb_y, filter = ~ gene_biotype == "lincRNA")

#+END_SRC


To get an overview of database tables and available columns the function
=listTables= can be used. The method =listColumns= on the other hand lists columns
for the specified database table.

#+NAME: list-columns
#+BEGIN_SRC R
  ## list all database tables along with their columns
  listTables(edb)

  ## list columns from a specific table
  listColumns(edb, "tx")

#+END_SRC

Thus, we could retrieve all transcripts of the biotype /nonsense_mediated_decay/
(which, according to the definitions by Ensembl are transcribed, but most likely
not translated in a protein, but rather degraded after transcription) along with
the name of the gene for each transcript. Note that we are changing here the
=return.type= to =DataFrame=, so the method will return a =DataFrame= with the
results instead of the default =GRanges=.

#+NAME: transcripts-example2
#+BEGIN_SRC R
  Tx <- transcripts(edb,
		    columns = c(listColumns(edb , "tx"), "gene_name"),
		    filter = TxBiotypeFilter("nonsense_mediated_decay"),
		    return.type = "DataFrame")
  nrow(Tx)
  Tx

#+END_SRC

For protein coding transcripts, we can also specifically extract their coding
region. In the example below we extract the CDS for all transcripts encoded on
chromosome Y.

#+NAME: cdsBy
#+BEGIN_SRC R
  yCds <- cdsBy(edb, filter = SeqNameFilter("Y"))
  yCds

#+END_SRC

Using a =GRangesFilter= we can retrieve all features from the database that are
either within or overlapping the specified genomic region. In the example
below we query all genes that are partially overlapping with a small region on
chromosome 11. The filter restricts to all genes for which either an exon or an
intron is partially overlapping with the region.

#+NAME: genes-GRangesFilter
#+BEGIN_SRC R
  ## Define the filter
  grf <- GRangesFilter(GRanges("11", ranges = IRanges(114129278, 114129328),
			       strand = "+"), type = "any")

  ## Query genes:
  gn <- genes(edb, filter = grf)
  gn

  ## Next we retrieve all transcripts for that gene so that we can plot them.
  txs <- transcripts(edb, filter = GenenameFilter(gn$gene_name))

#+END_SRC

#+NAME: granges-zbtb16
#+BEGIN_SRC R :ravel message = FALSE, fig.align = 'center', echo = FALSE
  plot(3, 3, pch = NA, xlim = c(start(gn), end(gn)), ylim = c(0, length(txs)),
       yaxt = "n", ylab = "")
  ## Highlight the GRangesFilter region
  rect(xleft = start(grf), xright = end(grf), ybottom = 0, ytop = length(txs),
       col = "red", border = "red")
  for(i in 1:length(txs)) {
      current <- txs[i]
      rect(xleft = start(current), xright = end(current), ybottom = i-0.975,
           ytop = i-0.125, border = "grey")
      text(start(current), y = i-0.5, pos = 4, cex = 0.75, labels = current$tx_id)
  }

#+END_SRC

As we can see, 4 transcripts of the gene ZBTB16 are also overlapping the
region. Below we fetch these 4 transcripts. Note, that a call to =exons= will
not return any features from the database, as no exon is overlapping with the
region.

#+NAME: transcripts-GRangesFilter
#+BEGIN_SRC R
  transcripts(edb, filter = grf)

#+END_SRC

The =GRangesFilter= supports also =GRanges= defining multiple regions and a
query will return all features overlapping any of these regions. Besides using
the =GRangesFilter= it is also possible to search for transcripts or exons
overlapping genomic regions using the =exonsByOverlaps= or
=transcriptsByOverlaps= known from the =GenomicFeatures= package. Note that the
implementation of these methods for =EnsDb= objects supports also to use filters
to further fine-tune the query.

The functions =listGenebiotypes= and =listTxbiotypes= can be used to get an overview
of allowed/available gene and transcript biotype

#+NAME: biotypes
#+BEGIN_SRC R
  ## Get all gene biotypes from the database. The GeneBiotypeFilter
  ## allows to filter on these values.
  listGenebiotypes(edb)

  ## Get all transcript biotypes from the database.
  listTxbiotypes(edb)

#+END_SRC

Data can be fetched in an analogous way using the =exons= and =genes=
methods. In the example below we retrieve =gene_name=, =entrezid= and the
=gene_biotype= of all genes in the database which names start with "BCL2".

#+NAME: genes-BCL2
#+BEGIN_SRC R
  ## We're going to fetch all genes which names start with BCL.
  BCLs <- genes(edb,
		columns = c("gene_name", "entrezid", "gene_biotype"),
		filter = GenenameFilter("BCL", condition = "startsWith"),
		return.type = "DataFrame")
  nrow(BCLs)
  BCLs

#+END_SRC

Sometimes it might be useful to know the length of genes or transcripts
(i.e. the total sum of nucleotides covered by their exons). Below we calculate
the mean length of transcripts from protein coding genes on chromosomes X and Y
as well as the average length of snoRNA, snRNA and rRNA transcripts encoded on
these chromosomes. For the first query we combine two =AnnotationFilter= objects
using an =AnnotationFilterList= object, in the second we define the query using a
filter expression.

#+NAME: example-AnnotationFilterList
#+BEGIN_SRC R
  ## determine the average length of snRNA, snoRNA and rRNA genes encoded on
  ## chromosomes X and Y.
  mean(lengthOf(edb, of = "tx",
		filter = AnnotationFilterList(
		    GeneBiotypeFilter(c("snRNA", "snoRNA", "rRNA")),
		    SeqNameFilter(c("X", "Y")))))

  ## determine the average length of protein coding genes encoded on the same
  ## chromosomes.
  mean(lengthOf(edb, of = "tx",
		filter = ~ gene_biotype == "protein_coding" &
		    seq_name %in% c("X", "Y")))

#+END_SRC

Not unexpectedly, transcripts of protein coding genes are longer than those of
snRNA, snoRNA or rRNA genes.

At last we extract the first two exons of each transcript model from the
database.

#+NAME: example-first-two-exons
#+BEGIN_SRC R
  ## Extract all exons 1 and (if present) 2 for all genes encoded on the
  ## Y chromosome
  exons(edb, columns = c("tx_id", "exon_idx"),
	filter = list(SeqNameFilter("Y"),
                      ExonRankFilter(3, condition = "<")))

#+END_SRC

* Extracting gene/transcript/exon models for RNASeq feature counting

For the feature counting step of an RNAseq experiment, the gene or transcript
models (defined by the chromosomal start and end positions of their exons) have
to be known. To extract these from an Ensembl based annotation package, the
=exonsBy=, =genesBy= and =transcriptsBy= methods can be used in an analogous way as in
=TxDb= packages generated by the =GenomicFeatures= package.  However, the
=transcriptsBy= method does not, in contrast to the method in the =GenomicFeatures=
package, allow to return transcripts by "cds". While the annotation packages
built by the =ensembldb= contain the chromosomal start and end coordinates of
the coding region (for protein coding genes) they do not assign an ID to each
CDS.

A simple use case is to retrieve all genes encoded on chromosomes X and Y from
the database.

#+NAME: transcriptsBy-X-Y
#+BEGIN_SRC R
  TxByGns <- transcriptsBy(edb, by = "gene", filter = SeqNameFilter(c("X", "Y")))
  TxByGns

#+END_SRC

Since Ensembl contains also definitions of genes that are on chromosome variants
(supercontigs), it is advisable to specify the chromosome names for which the
gene models should be returned.

In a real use case, we might thus want to retrieve all genes encoded on the
/standard/ chromosomes. In addition it is advisable to use a =GeneIdFilter= to
restrict to Ensembl genes only, as also /LRG/ (Locus Reference Genomic)
genes[fn:3] are defined in the database, which are partially redundant with
Ensembl genes.

#+NAME: exonsBy-RNAseq
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  ## will just get exons for all genes on chromosomes 1 to 22, X and Y.
  ## Note: want to get rid of the "LRG" genes!!!
  EnsGenes <- exonsBy(edb, by = "gene", filter = AnnotationFilterList(
					    SeqNameFilter(c(1:22, "X", "Y")),
					    GeneIdFilter("ENSG", "startsWith")))

#+END_SRC

The code above returns a =GRangesList= that can be used directly as an input for
the =summarizeOverlaps= function from the =GenomicAlignments= package [fn:4].

Alternatively, the above =GRangesList= can be transformed to a =data.frame= in
/SAF/ format that can be used as an input to the =featureCounts= function of the
=Rsubread= package [fn:5].

#+NAME: toSAF-RNAseq
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  ## Transforming the GRangesList into a data.frame in SAF format
  EnsGenes.SAF <- toSAF(EnsGenes)

#+END_SRC

Note that the ID by which the =GRangesList= is split is used in the SAF
formatted =data.frame= as the =GeneID=. In the example below this would be the
Ensembl gene IDs, while the start, end coordinates (along with the strand and
chromosomes) are those of the the exons.

In addition, the =disjointExons= function (similar to the one defined in
=GenomicFeatures=) can be used to generate a =GRanges= of non-overlapping exon
parts which can be used in the =DEXSeq= package.

#+NAME: disjointExons
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  ## Create a GRanges of non-overlapping exon parts.
  DJE <- disjointExons(edb, filter = AnnotationFilterList(
				SeqNameFilter(c(1:22, "X", "Y")),
				GeneIdFilter("ENSG%", "startsWith")))

#+END_SRC

* Retrieving sequences for gene/transcript/exon models

The methods to retrieve exons, transcripts and genes (i.e. =exons=, =transcripts=
and =genes=) return by default =GRanges= objects that can be used to retrieve
sequences using the =getSeq= method e.g. from BSgenome packages. The basic
workflow is thus identical to the one for =TxDb= packages, however, it is not
straight forward to identify the BSgenome package with the matching genomic
sequence. Most BSgenome packages are named according to the genome build
identifier used in UCSC which does not (always) match the genome build name used
by Ensembl. Using the Ensembl version provided by the =EnsDb=, the correct genomic
sequence can however be retrieved easily from the =AnnotationHub= using the
=getGenomeFaFile=. If no Fasta file matching the Ensembl version is available, the
function tries to identify a Fasta file with the correct genome build from the
/closest/ Ensembl release and returns that instead.

In the code block below we retrieve first the =FaFile= with the genomic DNA
sequence, extract the genomic start and end coordinates for all genes defined in
the package, subset to genes encoded on sequences available in the =FaFile= and
extract all of their sequences. Note: these sequences represent the sequence
between the chromosomal start and end coordinates of the gene.

#+NAME: transcript-sequence-AnnotationHub
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  library(EnsDb.Hsapiens.v86)
  library(Rsamtools)
  edb <- EnsDb.Hsapiens.v86

  ## Get the FaFile with the genomic sequence matching the Ensembl version
  ## using the AnnotationHub package.
  Dna <- getGenomeFaFile(edb)

  ## Get start/end coordinates of all genes.
  genes <- genes(edb)
  ## Subset to all genes that are encoded on chromosomes for which
  ## we do have DNA sequence available.
  genes <- genes[seqnames(genes) %in% seqnames(seqinfo(Dna))]

  ## Get the gene sequences, i.e. the sequence including the sequence of
  ## all of the gene's exons and introns.
  geneSeqs <- getSeq(Dna, genes)

#+END_SRC

To retrieve the (exonic) sequence of transcripts (i.e. without introns) we can
use directly the =extractTranscriptSeqs= method defined in the =GenomicFeatures= on
the =EnsDb= object, eventually using a filter to restrict the query.

#+NAME: transcript-sequence-extractTranscriptSeqs
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  ## get all exons of all transcripts encoded on chromosome Y
  yTx <- exonsBy(edb, filter = SeqNameFilter("Y"))

  ## Retrieve the sequences for these transcripts from the FaFile.
  library(GenomicFeatures)
  yTxSeqs <- extractTranscriptSeqs(Dna, yTx)
  yTxSeqs

  ## Extract the sequences of all transcripts encoded on chromosome Y.
  yTx <- extractTranscriptSeqs(Dna, edb, filter = SeqNameFilter("Y"))

  ## Along these lines, we could use the method also to retrieve the coding sequence
  ## of all transcripts on the Y chromosome.
  cdsY <- cdsBy(edb, filter = SeqNameFilter("Y"))
  extractTranscriptSeqs(Dna, cdsY)

#+END_SRC


Next we retrieve transcript sequences from genes encoded on chromosome Y using
the =BSGenome= package for the human genome. Ensembl version 86 based on
the =GRCh38= genome build and we thus load the corresponding =BSGenome= package.

#+NAME: extractTranscriptSeqs-BSGenome
#+BEGIN_SRC R :ravel warning = FALSE, message = FALSE
  library(BSgenome.Hsapiens.NCBI.GRCh38)
  bsg <- BSgenome.Hsapiens.NCBI.GRCh38

  ## Get the genome version
  unique(genome(bsg))
  unique(genome(edb))

  ## Extract the full transcript sequences.
  yTxSeqs <- extractTranscriptSeqs(bsg, exonsBy(edb, "tx",
						filter = SeqNameFilter("Y")))

  yTxSeqs

  ## Extract just the CDS
  Test <- cdsBy(edb, "tx", filter = SeqNameFilter("Y"))
  yTxCds <- extractTranscriptSeqs(bsg, cdsBy(edb, "tx",
					     filter = SeqNameFilter("Y")))
  yTxCds

#+END_SRC

* Integrating annotations from Ensembl based =EnsDb= packages with UCSC based annotations

Sometimes it might be useful to combine (Ensembl based) annotations from =EnsDb=
packages/objects with annotations from other Bioconductor packages, that might
base on UCSC annotations. To support such an integration of annotations, the
=ensembldb= packages implements the =seqlevelsStyle= and =seqlevelsStyle<-= from the
=GenomeInfoDb= package that allow to change the style of chromosome naming.  Thus,
sequence/chromosome names other than those used by Ensembl can be used in, and
are returned by, the queries to =EnsDb= objects as long as a mapping for them is
provided by the =GenomeInfoDb= package (which provides a mapping mostly between
UCSC, NCBI and Ensembl chromosome names for the /main/ chromosomes).

In the example below we change the seqnames style to UCSC.

#+NAME: seqlevelsStyle
#+BEGIN_SRC R :ravel message = FALSE
  ## Change the seqlevels style form Ensembl (default) to UCSC:
  seqlevelsStyle(edb) <- "UCSC"

  ## Now we can use UCSC style seqnames in SeqNameFilters or GRangesFilter:
  genesY <- genes(edb, filter = ~ seq_name == "chrY")
  ## The seqlevels of the returned GRanges are also in UCSC style
  seqlevels(genesY)

#+END_SRC

Note that in most instances no mapping is available for sequences not
corresponding to the main chromosomes (i.e. contigs, patched chromosomes
etc). What is returned in cases in which no mapping is available can be
specified with the global =ensembldb.seqnameNotFound= option. By default (with
=ensembldb.seqnameNotFound= set to "ORIGINAL"), the original seqnames (i.e. the
ones from Ensembl) are returned. With =ensembldb.seqnameNotFound= "MISSING" each
time a seqname can not be found an error is thrown. For all other cases
(e.g. =ensembldb.seqnameNotFound = NA=) the value of the option is returned.

#+NAME: seqlevelsStyle-2
#+BEGIN_SRC R :ravel message = FALSE
  seqlevelsStyle(edb) <- "UCSC"

  ## Getting the default option:
  getOption("ensembldb.seqnameNotFound")

  ## Listing all seqlevels in the database.
  seqlevels(edb)[1:30]

  ## Setting the option to NA, thus, for each seqname for which no mapping is available,
  ## NA is returned.
  options(ensembldb.seqnameNotFound=NA)
  seqlevels(edb)[1:30]

  ## Resetting the option.
  options(ensembldb.seqnameNotFound = "ORIGINAL")

#+END_SRC

At last changing the seqname style to the default value ="Ensembl"=.

#+NAME: seqlevelsStyle-restore
#+BEGIN_SRC R
  seqlevelsStyle(edb) <- "Ensembl"

#+END_SRC

* Interactive annotation lookup using the =shiny= web app

In addition to the =genes=, =transcripts= and =exons= methods it is possibly to
search interactively for gene/transcript/exon annotations using the internal,
=shiny= based, web application. The application can be started with the
=runEnsDbApp()= function. The search results from this app can also be returned
to the R workspace either as a =data.frame= or =GRanges= object.

* Plotting gene/transcript features using =ensembldb= and =Gviz= and =ggbio=

The =Gviz= package provides functions to plot genes and transcripts along with
other data on a genomic scale. Gene models can be provided either as a
=data.frame=, =GRanges=, =TxDB= database, can be fetched from biomart and can
also be retrieved from =ensembldb=.

Below we generate a =GeneRegionTrack= fetching all transcripts from a certain
region on chromosome Y.

Note that if we want in addition to work also with BAM files that were aligned
against DNA sequences retrieved from Ensembl or FASTA files representing genomic
DNA sequences from Ensembl we should change the =ucscChromosomeNames= option from
=Gviz= to =FALSE= (i.e. by calling =options(ucscChromosomeNames = FALSE)=).  This is
not necessary if we just want to retrieve gene models from an =EnsDb= object, as
the =ensembldb= package internally checks the =ucscChromosomeNames= option and,
depending on that, maps Ensembl chromosome names to UCSC chromosome names.


#+NAME: gviz-plot
#+BEGIN_SRC R :ravel gviz-plot, message=FALSE, fig.align = 'center', fig.width=7.5, fig.height=2.3
  ## Loading the Gviz library
  library(Gviz)
  library(EnsDb.Hsapiens.v86)
  edb <- EnsDb.Hsapiens.v86

  ## Retrieving a Gviz compatible GRanges object with all genes
  ## encoded on chromosome Y.
  gr <- getGeneRegionTrackForGviz(edb, chromosome = "Y",
				  start = 20400000, end = 21400000)
  ## Define a genome axis track
  gat <- GenomeAxisTrack()

  ## We have to change the ucscChromosomeNames option to FALSE to enable Gviz usage
  ## with non-UCSC chromosome names.
  options(ucscChromosomeNames = FALSE)

  plotTracks(list(gat, GeneRegionTrack(gr)))

  options(ucscChromosomeNames = TRUE)

#+END_SRC

Above we had to change the option =ucscChromosomeNames= to =FALSE= in order to
use it with non-UCSC chromosome names. Alternatively, we could however also
change the =seqnamesStyle= of the =EnsDb= object to =UCSC=. Note that we have to
use now also chromosome names in the /UCSC style/ in the =SeqNameFilter=
(i.e. "chrY" instead of "Y").

#+BEGIN_SRC R :ravel message=FALSE
  seqlevelsStyle(edb) <- "UCSC"
  ## Retrieving the GRanges objects with seqnames corresponding to UCSC chromosome names.
  gr <- getGeneRegionTrackForGviz(edb, chromosome = "chrY",
                                  start = 20400000, end = 21400000)
  seqnames(gr)
  ## Define a genome axis track
  gat <- GenomeAxisTrack()
  plotTracks(list(gat, GeneRegionTrack(gr)))

#+END_SRC

We can also use the filters from the =ensembldb= package to further refine what
transcripts are fetched, like in the example below, in which we create two
different gene region tracks, one for protein coding genes and one for lincRNAs.

#+NAME: gviz-separate-tracks
#+BEGIN_SRC R :ravel message=FALSE, warning=FALSE, fig.align='center', fig.width=7.5, fig.height=2.25
  protCod <- getGeneRegionTrackForGviz(edb, chromosome = "chrY",
				       start = 20400000, end = 21400000,
				       filter = GeneBiotypeFilter("protein_coding"))
  lincs <- getGeneRegionTrackForGviz(edb, chromosome = "chrY",
				     start = 20400000, end = 21400000,
				     filter = GeneBiotypeFilter("lincRNA"))

  plotTracks(list(gat, GeneRegionTrack(protCod, name = "protein coding"),
		  GeneRegionTrack(lincs, name = "lincRNAs")), transcriptAnnotation = "symbol")

  ## At last we change the seqlevels style again to Ensembl
  seqlevelsStyle <- "Ensembl"

#+END_SRC

Alternatively, we can also use =ggbio= for plotting. For =ggbio= we can directly
pass the =EnsDb= object along with optional filters (or as in the example below a
filter expression as a =formula=).

#+NAME: pplot-plot
#+BEGIN_SRC R :ravel message = FALSE, fig.align='center', fig.width=7.5, fig.height=4
  library(ggbio)

  ## Create a plot for all transcripts of the gene SKA2
  autoplot(edb, ~ genename == "SKA2")

#+END_SRC

To plot the genomic region and plot genes from both strands we can use a
=GRangesFilter=.


#+NAME: pplot-plot-2
#+BEGIN_SRC R :ravel message = FALSE, fig.align='center', fig.width=7.5, fig.height=4
  ## Get the chromosomal region in which the gene is encoded
  ska2 <- genes(edb, filter = ~ genename == "SKA2")
  strand(ska2) <- "*"
  autoplot(edb, GRangesFilter(ska2), names.expr = "gene_name")

#+END_SRC

* Using =EnsDb= objects in the =AnnotationDbi= framework

Most of the methods defined for objects extending the basic annotation package
class =AnnotationDbi= are also defined for =EnsDb= objects (i.e. methods
=columns=, =keytypes=, =keys=, =mapIds= and =select=). While these methods can
be used analogously to basic annotation packages, the implementation for =EnsDb=
objects also support the filtering framework of the =ensembldb= package.

In the example below we first evaluate all the available columns and keytypes in
the database and extract then the gene names for all genes encoded on chromosome
X.

#+NAME: AnnotationDbi
#+BEGIN_SRC R :ravel message = FALSE
  library(EnsDb.Hsapiens.v86)
  edb <- EnsDb.Hsapiens.v86

  ## List all available columns in the database.
  columns(edb)

  ## Note that these do *not* correspond to the actual column names
  ## of the database that can be passed to methods like exons, genes,
  ## transcripts etc. These column names can be listed with the listColumns
  ## method.
  listColumns(edb)

  ## List all of the supported key types.
  keytypes(edb)

  ## Get all gene ids from the database.
  gids <- keys(edb, keytype = "GENEID")
  length(gids)

  ## Get all gene names for genes encoded on chromosome Y.
  gnames <- keys(edb, keytype = "GENENAME", filter = SeqNameFilter("Y"))
  head(gnames)

#+END_SRC

In the next example we retrieve specific information from the database using the
=select= method. First we fetch all transcripts for the genes /BCL2/ and
/BCL2L11/. In the first call we provide the gene names, while in the second call
we employ the filtering system to perform a more fine-grained query to fetch
only the protein coding transcripts for these genes.

#+NAME: select
#+BEGIN_SRC R :ravel message = FALSE, warning=FALSE
  ## Use the /standard/ way to fetch data.
  select(edb, keys = c("BCL2", "BCL2L11"), keytype = "GENENAME",
	 columns = c("GENEID", "GENENAME", "TXID", "TXBIOTYPE"))

  ## Use the filtering system of ensembldb
  select(edb, keys = ~ genename %in% c("BCL2", "BCL2L11") &
		  tx_biotype == "protein_coding",
	 columns = c("GENEID", "GENENAME", "TXID", "TXBIOTYPE"))

#+END_SRC

Finally, we use the =mapIds= method to establish a mapping between ids and
values. In the example below we fetch transcript ids for the two genes from the
example above.

#+NAME: mapIds
#+BEGIN_SRC R :ravel message = FALSE
  ## Use the default method, which just returns the first value for multi mappings.
  mapIds(edb, keys = c("BCL2", "BCL2L11"), column = "TXID", keytype = "GENENAME")

  ## Alternatively, specify multiVals="list" to return all mappings.
  mapIds(edb, keys = c("BCL2", "BCL2L11"), column = "TXID", keytype = "GENENAME",
	 multiVals = "list")

  ## And, just like before, we can use filters to map only to protein coding transcripts.
  mapIds(edb, keys = list(GenenameFilter(c("BCL2", "BCL2L11")),
                          TxBiotypeFilter("protein_coding")), column = "TXID",
	 multiVals = "list")

#+END_SRC

Note that, if the filters are used, the ordering of the result does no longer
match the ordering of the genes.

* Important notes

These notes might explain eventually unexpected results (and, more importantly,
help avoiding them):

+ The ordering of the results returned by the =genes=, =exons=, =transcripts= methods
  can be specified with the =order.by= parameter. The ordering of the results does
  however *not* correspond to the ordering of values in submitted filter
  objects. The exception is the =select= method. If a character vector of values
  or a single filter is passed with argument =keys= the ordering of results of
  this method matches the ordering of the key values or the values of the
  filter.

+ Results of =exonsBy=, =transcriptsBy= are always ordered by the =by= argument.

+ The CDS provided by =EnsDb= objects *always* includes both, the start and the
  stop codon.

+ Transcripts with multiple CDS are at present not supported by =EnsDb=.

+ At present, =EnsDb= support only genes/transcripts for which all of their
  exons are encoded on the same chromosome and the same strand.

+ Since a single Ensembl gene ID might be mapped to multiple NCBI Entrezgene IDs
  methods such as =genes=, =transcripts= etc return a =list= in the ="entrezid"= column
  of the resulting result object.

* Getting or building =EnsDb= databases/packages

Some of the code in this section is not supposed to be automatically executed
when the vignette is built, as this would require a working installation of the
Ensembl Perl API, which is not expected to be available on each system. Also,
building =EnsDb= from alternative sources, like GFF or GTF files takes some time
and thus also these examples are not directly executed when the vignette is
build.

** Getting =EnsDb= databases

Some =EnsDb= databases are available as =R= packages from Bioconductor and can be
simply installed with the =biocLite= function from the =BiocInstaller= package. The
name of such annotation packages starts with /EnsDb/ followed by the abbreviation
of the organism and the Ensembl version on which the annotation
bases. =EnsDb.Hsapiens.v86= provides thus an =EnsDb= database for homo sapiens with
annotations from Ensembl version 86.

Since Bioconductor version 3.5 =EnsDb= databases can also be retrieved directly
from =AnnotationHub=.

#+NAME: AnnotationHub-query
#+BEGIN_SRC R :ravel message = FALSE, eval = use_network
  library(AnnotationHub)
  ## Load the annotation resource.
  ah <- AnnotationHub()

  ## Query for all available EnsDb databases
  query(ah, "EnsDb")

#+END_SRC

We can simply fetch one of the databases.

#+NAME: AnnotationHub-query-2
#+BEGIN_SRC R :ravel message = FALSE, eval = use_network
  ahDb <- query(ah, pattern = c("Xiphophorus Maculatus", "EnsDb", 87))
  ## What have we got
  ahDb

#+END_SRC

Fetch the =EnsDb= and use it.

#+NAME: AnnotationHub-fetch
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  ahEdb <- ahDb[[1]]

  ## retriebe all genes
  gns <- genes(ahEdb)

#+END_SRC

We could even make an annotation package from this =EnsDb= object using the
=makeEnsembldbPackage= and passing =dbfile(dbconn(ahEdb))= as =ensdb= argument.


** Building annotation packages

*** Directly from Ensembl databases

The =fetchTablesFromEnsembl= function uses the Ensembl Perl API
to retrieve the required annotations from an Ensembl database (e.g. from the
main site /ensembldb.ensembl.org/). Thus, to use this functionality to build
databases, the Ensembl Perl API needs to be installed (see [fn:2] for details).

Below we create an =EnsDb= database by fetching the required data directly from
the Ensembl core databases. The =makeEnsembldbPackage= function is then used to
create an annotation package from this =EnsDb= containing all human genes for
Ensembl version 75.

#+NAME: edb-from-ensembl
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  library(ensembldb)

  ## get all human gene/transcript/exon annotations from Ensembl (75)
  ## the resulting tables will be stored by default to the current working
  ## directory
  fetchTablesFromEnsembl(75, species = "human")

  ## These tables can then be processed to generate a SQLite database
  ## containing the annotations (again, the function assumes the required
  ## txt files to be present in the current working directory)
  DBFile <- makeEnsemblSQLiteFromTables()

  ## and finally we can generate the package
  makeEnsembldbPackage(ensdb = DBFile, version = "0.99.12",
                       maintainer = "Johannes Rainer <johannes.rainer@eurac.edu>",
                       author = "J Rainer")

#+END_SRC

The generated package can then be build using =R CMD build EnsDb.Hsapiens.v75=
and installed with =R CMD INSTALL EnsDb.Hsapiens.v75*=.  Note that we could
directly generate an =EnsDb= instance by loading the database file, i.e. by
calling =edb <- EnsDb(DBFile)= and work with that annotation object.

To fetch and build annotation packages for plant genomes (e.g. arabidopsis
thaliana), the /Ensembl genomes/ should be specified as a host, i.e. setting
=host= to "mysql-eg-publicsql.ebi.ac.uk", =port= to =4157= and =species= to
e.g. "arabidopsis thaliana".


*** From a GTF or GFF file

Alternatively, the =ensDbFromAH=, =ensDbFromGff=, =ensDbFromGRanges= and =ensDbFromGtf=
functions allow to build EnsDb SQLite files from a =GRanges= object or GFF/GTF
files from Ensembl (either provided as files or /via/ =AnnotationHub=). These
functions do not depend on the Ensembl Perl API, but require a working internet
connection to fetch the chromosome lengths from Ensembl as these are not
provided within GTF or GFF files. Also note that protein annotations are usually
not available in GTF or GFF files, thus, such annotations will not be included
in the generated =EnsDb= database - protein annotations are only available in
=EnsDb= databases created with the Ensembl Perl API (such as the ones provided
through =AnnotationHub= or as Bioconductor packages).

In the next example we create an =EnsDb= database using the =AnnotationHub=
package and load also the corresponding genomic DNA sequence matching the
Ensembl version. We thus first query the =AnnotationHub= package for all
resources available for =Mus musculus= and the Ensembl release 77. Next we
create the =EnsDb= object from the appropriate =AnnotationHub= resource.  We
then use the =getGenomeFaFile= method on the =EnsDb= to directly look up and
retrieve the correct or best matching =FaFile= with the genomic DNA sequence. At
last we retrieve the sequences of all exons using the =getSeq= method.

#+NAME: gtf-gff-edb
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  ## Load the AnnotationHub data.
  library(AnnotationHub)
  ah <- AnnotationHub()

  ## Query all available files for Ensembl release 77 for
  ## Mus musculus.
  query(ah, c("Mus musculus", "release-77"))

  ## Get the resource for the gtf file with the gene/transcript definitions.
  Gtf <- ah["AH28822"]
  ## Create a EnsDb database file from this.
  DbFile <- ensDbFromAH(Gtf)
  ## We can either generate a database package, or directly load the data
  edb <- EnsDb(DbFile)


  ## Identify and get the FaFile object with the genomic DNA sequence matching
  ## the EnsDb annotation.
  Dna <- getGenomeFaFile(edb)
  library(Rsamtools)
  ## We next retrieve the sequence of all exons on chromosome Y.
  exons <- exons(edb, filter = SeqNameFilter("Y"))
  exonSeq <- getSeq(Dna, exons)

  ## Alternatively, look up and retrieve the toplevel DNA sequence manually.
  Dna <- ah[["AH22042"]]

#+END_SRC

In the example below we load a =GRanges= containing gene definitions for genes
encoded on chromosome Y and generate a =EnsDb= SQLite database from that
information.

#+NAME: EnsDb-from-Y-GRanges
#+BEGIN_SRC R :ravel message = FALSE, eval = use_network
  ## Generate a sqlite database from a GRanges object specifying
  ## genes encoded on chromosome Y
  load(system.file("YGRanges.RData", package = "ensembldb"))
  Y

  ## Create the EnsDb database file
  DB <- ensDbFromGRanges(Y, path = tempdir(), version = 75,
			 organism = "Homo_sapiens")

  ## Load the database
  edb <- EnsDb(DB)
  edb

#+END_SRC


Alternatively we can build the annotation database using the =ensDbFromGtf=
=ensDbFromGff= functions, that extract most of the required data from a GTF
respectively GFF (version 3) file which can be downloaded from Ensembl
(e.g. from ftp://ftp.ensembl.org/pub/release-75/gtf/homo_sapiens for human gene
definitions from Ensembl version 75; for plant genomes etc, files can be
retrieved from ftp://ftp.ensemblgenomes.org). All information except the
chromosome lengths, the NCBI Entrezgene IDs and protein annotations can be
extracted from these GTF files. The function also tries to retrieve chromosome
length information automatically from Ensembl.

Below we create the annotation from a gtf file that we fetch directly from Ensembl.

#+NAME: EnsDb-from-GTF
#+BEGIN_SRC R :ravel message = FALSE, eval = FALSE
  library(ensembldb)

  ## the GTF file can be downloaded from
  ## ftp://ftp.ensembl.org/pub/release-75/gtf/homo_sapiens/
  gtffile <- "Homo_sapiens.GRCh37.75.gtf.gz"
  ## generate the SQLite database file
  DB <- ensDbFromGtf(gtf = gtffile)

  ## load the DB file directly
  EDB <- EnsDb(DB)

  ## alternatively, build the annotation package
  ## and finally we can generate the package
  makeEnsembldbPackage(ensdb = DB, version = "0.99.12",
                       maintainer = "Johannes Rainer <johannes.rainer@eurac.edu>",
                       author = "J Rainer")

#+END_SRC

* Database layout<<section.database.layout>>

The database consists of the following tables and attributes (the layout is also
shown in Figure [[fig.database.layout]]). Note that the protein-specific annotations
might not be available in all =EnsDB= databases (e.g. such ones created with
=ensembldb= version < 1.7 or created from GTF or GFF files).

+ *gene*: all gene specific annotations.
  - =gene_id=: the Ensembl ID of the gene.
  - =gene_name=: the name (symbol) of the gene.
  - =gene_biotype=: the biotype of the gene.
  - =gene_seq_start=: the start coordinate of the gene on the sequence (usually
    a chromosome).
  - =gene_seq_end=: the end coordinate of the gene on the sequence.
  - =seq_name=: the name of the sequence (usually the chromosome name).
  - =seq_strand=: the strand on which the gene is encoded.
  - =seq_coord_system=: the coordinate system of the sequence.
  - =description=: the description of the gene.

+ *entrezgene*: mapping of Ensembl genes to NCBI Entrezgene identifiers. Note that
  this mapping can be a one-to-many mapping.
  - =gene_id=: the Ensembl gene ID.
  - =entrezid=: the NCBI Entrezgene ID.

+ *tx*: all transcript related annotations. Note that while no =tx_name= column
  is available in this database column, all methods to retrieve data from the
  database support also this column. The returned values are however the ID of
  the transcripts.
  - =tx_id=: the Ensembl transcript ID.
  - =tx_biotype=: the biotype of the transcript.
  - =tx_seq_start=: the start coordinate of the transcript.
  - =tx_seq_end=: the end coordinate of the transcript.
  - =tx_cds_seq_start=: the start coordinate of the coding region of the
    transcript (NULL for non-coding transcripts).
  - =tx_cds_seq_end=: the end coordinate of the coding region of the transcript.
  - =gene_id=: the gene to which the transcript belongs.
  =EnsDb= databases for more recent Ensembl releases have also a column
  =tx_support_level= providing the evidence level for a transcript (1 high
  evidence, 5 low evidence, NA no evidence calculated).

+ *exon*: all exon related annotation.
  - =exon_id=: the Ensembl exon ID.
  - =exon_seq_start=: the start coordinate of the exon.
  - =exon_seq_end=: the end coordinate of the exon.

+ *tx2exon*: provides the n:m mapping between transcripts and exons.
  - =tx_id=: the Ensembl transcript ID.
  - =exon_id=: the Ensembl exon ID.
  - =exon_idx=: the index of the exon in the corresponding transcript, always
    from 5' to 3' of the transcript.

+ *chromosome*: provides some information about the chromosomes.
  - =seq_name=: the name of the sequence/chromosome.
  - =seq_length=: the length of the sequence.
  - =is_circular=: whether the sequence in circular.

+ *protein*: provides protein annotation for a (coding) transcript.
  - =protein_id=: the Ensembl protein ID.
  - =tx_id=: the transcript ID which CDS encodes the protein.
  - =protein_sequence=: the peptide sequence of the protein (translated from the
    transcript's coding sequence after applying eventual RNA editing).

+ *uniprot*: provides the mapping from Ensembl protein ID(s) to Uniprot ID(s). Not
  all Ensembl proteins are annotated to Uniprot IDs, also, each Ensembl protein
  might be mapped to multiple Uniprot IDs.
  - =protein_id=: the Ensembl protein ID.
  - =uniprot_id=: the Uniprot ID.
  - =uniprot_db=: the Uniprot database in which the ID is defined.
  - =uniprot_mapping_type=: the type of the mapping method that was used to assign
    the Uniprot ID to an Ensembl protein ID.

+ *protein_domain*: provides protein domain annotations and mapping to proteins.
  - =protein_id=: the Ensembl protein ID on which the protein domain is present.
  - =protein_domain_id=: the ID of the protein domain (from the protein domain
    source).
  - =protein_domain_source=: the source/analysis method in/by which the protein
    domain was defined (such as pfam etc).
  - =interpro_accession=: the Interpro accession ID of the protein domain.
  - =prot_dom_start=: the start position of the protein domain within the
    protein's sequence.
  - =prot_dom_end=: the end position of the protein domain within the protein's
    sequence.

+ *metadata*: some additional, internal, informations (Genome build, Ensembl
  version etc).
  - =name=
  - =value=

+ /virtual/ columns:
  - =symbol=: the database does not have such a database column, but it is still
    possible to use it in the =columns= parameter. This column is /symlinked/ to the
    =gene_name= column.
  - =tx_name=: similar to the =symbol= column, this column is /symlinked/ to the =tx_id=
    column.

The database layout: as already described above, protein related annotations
(green) might not be available in each =EnsDb= database.

#+NAME: fig.database.layout
#+CAPTION: Database layout.
[[file:images/dblayout.png]]


* Session information

#+NAME: sessionInfo
#+BEGIN_SRC R
  sessionInfo()
#+END_SRC

* Footnotes

[fn:1] http://www.ensembl.org

[fn:2] http://www.ensembl.org/info/docs/api/api_installation.html

[fn:3] http://www.lrg-sequence.org

[fn:4] http://www.ncbi.nlm.nih.gov/pubmed/23950696

[fn:5] http://www.ncbi.nlm.nih.gov/pubmed/24227677


* Installing the Ensembl database locally and building new packages :noexport:
:PROPERTIES:
:header-args: :eval never
:END:

This section covers the local installation of a new Ensembl database on my
system. Some of the perl scripts used here are available at
https://github.com/jotsetung/Ensembl-Exon-probemapping.

First of all we have to get the MySQL server up on my system. The MySQL server
was installed using =homebrew= and was configured to keep the databases on an
external disk.

Start the server using =mysql.server start=.

#+BEGIN_SRC shell
  ## Change to the directory with the perl script
  cd ~/Projects/git/Ensembl-Exon-probemapping/bin/

  ## Download and install the Ensembl core database
  perl installEnsembldb.pl -e 85 -d homo_sapiens_core_85_38

#+END_SRC




* TODOs								   :noexport:

** DONE Fix the =ensembldb:::EnsDb= call in /zzz.R/ of the package template!
   CLOSED: [2015-04-01 Wed 12:05]
   - State "DONE"       from "TODO"       [2015-04-01 Wed 12:05]

The =EnsDb= construction function is exported, thus there is no need for the =:::=.

** DONE Implement the =distjointExons= method.
   CLOSED: [2015-03-25 Wed 09:43]
   - State "DONE"       from "TODO"       [2015-03-25 Wed 09:43]
** DONE Fix return value for =organism=
   CLOSED: [2015-03-27 Fri 12:10]
   - State "DONE"       from "TODO"       [2015-03-27 Fri 12:10]

The return value should be /Genus species/, i.e. without =_= in between.
** DONE Check =utils::news=, =?news=
   CLOSED: [2015-04-02 Thu 08:50]
   - State "DONE"       from "TODO"       [2015-04-02 Thu 08:50]
** DONE build the database based on an Ensembl gtf file
   CLOSED: [2015-04-10 Fri 07:02]
   - State "DONE"       from "TODO"       [2015-04-10 Fri 07:02]
   - That would be the pre-requisite to write recipes for the =AnnotationHub= package.
   - The only missing data is the sequence lengths.
** DONE Use the =GenomicFeatures= =fetchChromLengthsFromEnsembl= to retrieve chromosome lengths for GTF import
   CLOSED: [2015-04-14 Tue 11:36]
   - State "DONE"       from "TODO"       [2015-04-14 Tue 11:36]

+ Ideally, automatically run this script, if there is any error just skip, but do not stop. To do that, use the =try= call.

** CANCELED Include recipe to =AnnotationHub=
   CLOSED: [2015-06-12 Fri 08:55]
   - State "CANCELED"   from "TODO"       [2015-06-12 Fri 08:55] \\
     Don't need that really. We can retrieve the GRanges object and build the EnsDb object or package based on that.
** CANCELED Implement a function to /guess/ the correct BSgenome package
   CLOSED: [2015-06-11 Thu 08:45]
   - State "CANCELED"   from "TODO"       [2015-06-11 Thu 08:45] \\
     Drop that; better to fetch the sequence from AnnotationHub!
+ In the end it seems I have to do some hard-coding there...


** DONE Implement a function to load the appropriate DNA sequence from AnnotationHub
   CLOSED: [2015-06-12 Fri 08:55]
   - State "DONE"       from "TODO"       [2015-06-12 Fri 08:55]
+ [X] Implement a method to retrieve the Ensembl version.
Some code snippet:
=query(ah, c(organism(edb), paste0("release-")))= and use =mcols()= on the result to search for =dna.toplevel.fa=.

** DONE Implement a function to build an EnsDb from a GRanges object.
   CLOSED: [2015-04-14 Tue 11:35]
   - State "DONE"       from "TODO"       [2015-04-14 Tue 11:35]
** DONE Implement the =cdsBy= method.
   CLOSED: [2015-10-30 Fri 09:15]
   - State "DONE"       from "TODO"       [2015-10-30 Fri 09:15]
This has to be implemented for =by= being ="tx"= and ="gene"=. Note that we can
*only* return this stuff for protein coding genes!!!
For =tx=:
- returns the exons constituting the cds. Returns a =GRangesList= with =GRanges=
  and metadata columns: =cds_id=, =cds_name=, =exon_rank=. The latter is clear,
  the other two are ?
- option =use.names= will return the TX ID.

For =gene=:
- Could we get that using =reduce=?

** DONE Implement the =fiveUTRsByTranscript= method.
   CLOSED: [2015-10-30 Fri 15:05]
   - State "DONE"       from "TODO"       [2015-10-30 Fri 15:05]


** DONE Implement the =threeUTRsByTranscript= method.
   CLOSED: [2015-10-30 Fri 15:05]
   - State "DONE"       from "TODO"       [2015-10-30 Fri 15:05]
** DONE Implement a method to use ensembldb for =Gviz=
   CLOSED: [2015-11-04 Wed 09:15]
   - State "DONE"       from "TODO"       [2015-11-04 Wed 09:15]
Do something similar to the .buildRange method for "TxDb" objects
(/Gviz-methods.R/). Ideally, the function should return a =GRanges= object (or
might a =data.frame= do as well?).

+ Implement a method that builds a =data.frame= for =Gviz=.
+ Check =.getBiotypeColor= function in /Gviz.R/ line 681.
+ Check =GeneRegionTrack= constructor in /AllClasses.R/, line 897 ->
  =.buildRanges= ()
+ =getGeneRegionTrackForGviz= should ideally return a =GRanges=, setting also
  the genome, seqinfo etc.
** WAIT Add a section in the vignette describing the use of =Gviz= with =ensembldb=
   - State "WAIT"       from "TODO"       [2015-11-06 Fri 08:41] \\
     Wait for Florian Hahne to add the changes to Gviz.


** DONE Implement a fix that would allow UCSC chromosome names [4/4]
   CLOSED: [2015-11-30 Mon 09:24]
   - State "DONE"       from "TODO"       [2015-11-30 Mon 09:24]
The idea is that, reading =options("ucscChromosomeNames")= a ="chr"= is appended
to the chromosome names. That way, =EnsDb= databases could directly work with
=Gviz= (as that package uses the above option).

+ If something is queried from the database, the ="chr"= has to be stripped
  off. Here we have to deal with the filters:
+ [X] =SeqNameFilter=: this now always returns stripped chr names, if =EnsDb= is
  also submitted.
+ [X] =GRangesFilter=
  and eventually using their =value= method:
+ If anything is returned from the database, a ="chr"= has to be appended, if
  the options are =TRUE=.
  - Looks like the major return path is =getWhat=, so, will include the replace
    stuff there.
+ [X] Adapt =getWhat=.
+ [X] The query to build the Gviz =GenePanel=.

** DONE Implement a fix to rename additional chromosome names, like =Mt= etc.
   CLOSED: [2015-11-30 Mon 08:59]
   - State "DONE"       from "TODO"       [2015-11-30 Mon 08:59]
** DONE Implement a =GRangesFilter= [2/2]
   CLOSED: [2015-11-27 Fri 13:59]
   - State "DONE"       from "TODO"       [2015-11-27 Fri 13:59]
+ [X] Filter should allow to either get all features =within= the GRanges:
  complete feature has to be within the range.
+ [X] All features overlapping: =overlappingExon=: part of an exon has to
  overlap the range. =overlappingAll=: exon or intron has to partially overlap
  the range.

+ Filter should use the coordinates of the things to fetch, i.e. gene,
  transcript or exon regions.

+ =within=: _seq_start >= start & _seq_end <= end.
+ =overlapping=: _seq_start <= end & _seq_end >= start.
- State "DONE"       from "TODO"       [2016-01-18 Mon 08:17]
** DONE Extend the =getGenomeFaFile= method
   CLOSED: [2016-01-18 Mon 08:17]

Search for the genome release matching the current Ensembl release, if not
present, search for a (Ensembl) =FaFile= matching the genome version and, if
more available, select the one with the closest release date or version.

** TODO Implement a =getGenomeTwiBitFile=.

The advantage over =getGenomeFaFile=? Eventually more =TwoBit= files might
become available in future.
Problem now is that the =seqinfo= for these guys seems a little problematic.

** TODO Implement some more =GenomicFeatures= methods [4/6]

+ [X] =transcriptLenghts=: use the =lengthOf= method.
+ [X] =transcriptsByOverlaps=: use the same code as in =GenomicFeatures=, but
  allow faster queries by first running the query to fetch only the specified
  chromosomes.
+ [X] =exonsByOverlaps=.
+ [X] Compare the two above methods with the /standard/ query and multi-region
  =GRangesFilter=.
(+ [ ] =cds=.) CANCELED. A cds without a transcript makes no sense...
+ [ ] =distance=, =nearest=.
+ [ ] =intronsByTranscript=.

** TODO Interface to the =OrganismDbi= database [/].

Basically, implementing the =AnnotationDbi= methods =columns=, =select=, =keys=
and =keytypes= methods should already be enough, but in addition I could
implement the two additional methods below... eventually.

+ [ ] Implement =selectByRanges(x, ranges, columns, overlaps, ignore.strand)=:
  supports multiple ranges. This returns a =GRanges= with one or more element(s)
  per input range or nothing, if nothing overlapped that region. =overlaps= can
  be =gene, tx, exons, cds, 5utr, introns or 3utr=.

+ [ ] Implement =selectRangesById=.

** DONE Interface the =AnnotationDbi= database [6/6]
   CLOSED: [2015-12-23 Wed 22:29]
   - State "DONE"       from "TODO"       [2015-12-23 Wed 22:29]
Implement the following methods:
+ [X] =columns=.
+ [X] =keytypes=.
+ [X] =keys=.
+ [X] =select=: I want to add a little more flexibility here: allow to specify,
  in addition to the standard usage of keys, keytypes etc, filter object(s) to
  perform some more fine-grained queries.
+ [X] =mapIds=.

+ [X] Add a section to the vignette.

** DONE Enhance the shiny app to return the search result.
   CLOSED: [2015-12-21 Mon 14:52]
   - State "DONE"       from "TODO"       [2015-12-21 Mon 14:52]

   - State "DONE"       from "TODO"       [2016-01-18 Mon 09:01]
** DONE Implement the =ensDbFromGff= function
   CLOSED: [2016-01-18 Mon 09:01]

We could also import stuff from GFF, not only GTF.


** DONE Fix a bug resulting in wrong CDS definitions form GTF files.
   CLOSED: [2016-01-19 Tue 13:41]
   - State "DONE"       from "TODO"       [2016-01-19 Tue 13:41]
I've to evaluate which is the correct way, the GFF info or the GTF, in which
start or stop codon can be outside of the coding region (which seems odd).
Check that with the Ensembl web page and eventually contact support!
** DONE Include functionality from the =GenomeInfoDb= to fix chromosome naming.
   CLOSED: [2016-02-02 Tue 07:21]

   - State "DONE"       from "TODO"       [2016-02-02 Tue 07:21]
+ [X] Implement a =seqlevelsStyle<-= method for =EnsDb=. Should do something
  similar than the stuff for =Gviz=. If =seqlevelStyle= is /Ensembl/ keep all as
  it is.
  Impact of that setter:
  - Queries support seqnames other than the ones from Ensembl.
  - Results have seqlevels set accordingly.
  - Check that the species is supported by =GenomeInfoDb=! Otherwise, return an error!
+ [X] Implement a =seqlevelsStyle= method for =EnsDb=.
+ [X] Implement central =formatSeqnamesForQuery= =formatSeqnamesFromQuery= methods (basically
  replacement for =ucscToEns= and =prefixChromName=).
+ [X] =EnsDb= needs a new slot to store any data (type list).
Specifically, use =mapSeqlevels=

+ *Note*: the global option =ensembldb.seqnameNotFound= allows to specify how
  the package handles missing mappings. Allowed are: =NA=, any value and special
  cases ="MISSING"= (causes an error) and ="ORIGINAL"= (returns the original
  names).

+ Methods/functions that should be affected:
  - [X] =getWhat=: always calling =formatSeqnamesFromQuery=.
  - [X] =seqinfo=: always calling =formatSeqnamesFromQuery=.
  - [X] =seqlevels=: always calling =formatSeqnamesFromQuery=.
  - [X] =exons=: uses =getWhat= and =seqinfo= (restricting to used seqnames).
  - [X] =exonsBy= uses =getWhat= and =seqinfo= (restricting to used seqnames).
  - [X] =genes= uses =getWhat= and =seqinfo= (restricting to used seqnames).
  - [X] =transcripts= uses =getWhat= and =seqinfo= (restricting to used seqnames).
  - [X] =transcriptsBy= uses =getWhat= and =seqinfo= (restricting to used seqnames).
  - [X] =SeqNameFilter=: always calling =formatSeqnamesForQuery=, does *not*
    allow =NA= values, thus doesn't work if the seqname can not be changed to
    Ensembl style.
  - [X] =GRangesFilter=: always calls =formatSeqnamesForQuery=.
  - [X] =threeUTRsByTranscript=
  - [X] =fiveUTRsByTranscript=
  - [X] =cdsBy= uses =getWhat= and =seqinfo= (restricting to used seqnames).
  - [X] =promoters=: uses =transcripts=.

+ [X] At last to verification: I could use the BSGenome package to retrieve
  sequence info from UCSC and cross check that sequence info with the two fasta
  files that are included in ensembldb.

+ [X] Add examples to the Vignette.

+ [X] Add help.

** DONE Allow more generic GTF file names in =ensDbFromGtf=
   CLOSED: [2016-01-21 Thu 17:15]
   - State "DONE"       from "TODO"       [2016-01-21 Thu 17:15]
Somehow I have to fix that it does not work with =chr.gtf.gz=.

** DONE For all queries, restrict the seqinfo to the chromosome names in the =GRanges=.
   CLOSED: [2016-02-01 Mon 08:53]
   - State "DONE"       from "TODO"       [2016-02-01 Mon 08:53]
** DONE =GRangesFilter= for multiple regions in =GRanges=
   CLOSED: [2016-02-04 Thu 08:02]

   - State "DONE"       from "TODO"       [2016-02-04 Thu 08:02]
Support multiple regions for a =GRangesFilter=.

** TODO Implement a method to convert variant information within =tx= to genomic coordinates

#+BEGIN_SRC R :eval never
  ## Get the genomic sequence
  fa <- getGenomeFaFile(edb)

  ## Convert variant coordinates to genomic coordinates
  tx <- "ENST00000070846"
  ## Get the cds
  txCds <- cdsBy(edb, by="tx", filter=TxIdFilter(tx))

  ## ENST00000070846:c.1643delG
  varPos <- 1643
  exWidths <- width(txCds[[tx]])
  ## Define the exon ends in the tx.
  exEnds <- cumsum(exWidths)
  ## Get the first negative index.
  exDiffs <- varPos - exEnds
  exVar <- min(which((exDiffs) < 0))
  ## Now we would like to know the position within that exon:
  posInExon <- exWidths[exVar] + exDiffs[exVar]
  ## Next the genomic coordinate:
  ## Note: here we have to consider the strand!
  ## fw: exon_start + (pos in exon -1)
  ## rv: exon_end - (pos in exon -1)
  if(as.character(strand(txCds[[tx]][1])) == "-"){
      chromPos <- end(txCds[[tx]][exVar]) - (posInExon - 1)
  }else{
      chromPos <- start(txCds[[tx]][exVar]) + (posInExon -1)
  }

  ## Validation.
  ## OK, now we get the sequence for that exon.
  ## Check if the estimated position is a G.
  exSeq <- getSeq(fa, txCds[[tx]][exVar])
  substring(exSeq, first=posInExon-2, last=posInExon+2)
  ## Hm, hard to tell... it's two Gs there!
  substring(exSeq, first=posInExon, last=posInExon) == "G"
  ## Get the full CDS
  cdsSeq <- unlist(getSeq(fa, txCds[[tx]]))
  substring(cdsSeq, first=varPos - 2, last=1643 + 2)
  ## The same.
  getSeq(fa, GRanges(seqnames=seqlevels(txCds[[tx]]),
                     IRanges(chromPos, chromPos), strand="-")) == "G"


  ## Next one is c.1881DelC:
  varPos <- 1881
  exDiffs <- varPos - exEnds
  exVar <- min(which(exDiffs < 0))
  posInExon <- exWidths[exVar] + exDiffs[exVar]
  exSeq <- getSeq(fa, txCds[[1]][exVar])
  substring(exSeq, first=posInExon - 2, last=posInExon + 2)
  ## Hm, again, we're right, but there are other 2 Cs there!

#+END_SRC

** DONE Implement a =SymbolFilter= and support a =symbol= column
   CLOSED: [2016-09-16 Fri 15:27]
   - State "DONE"       from "TODO"       [2016-09-16 Fri 15:27]

Done in issues #4 and #5.
** DONE What about using pipe and /formula-like/ filters?
   CLOSED: [2017-03-27 Mon 09:35]

   - State "DONE"       from "TODO"       [2017-03-27 Mon 09:35]
** DONE Fix the =select= method such that it always returns the values in the same order than the keys were
   CLOSED: [2016-09-16 Fri 15:26]
   - State "DONE"       from "TODO"       [2016-09-16 Fri 15:26]
This should be done if only a single filter was provided; for multiple filters
this will not work; could do it with a simple =match=.

This has been done in issue #1 on github.

** DONE *Always* return the attribute of the filter!
   CLOSED: [2016-09-16 Fri 15:26]
   - State "DONE"       from "TODO"       [2016-09-16 Fri 15:26]
I have to check that; eventually do that based on an user option, or even better
on an internal property, which can be set by =returnFilterCols(edb) <- TRUE/FALSE=.

Done in issue #6.

** CANCELED Integration with =Organism.dplyr=
   CLOSED: [2017-02-10 Fri 15:22]

   - State "CANCELED"   from "TODO"       [2017-02-10 Fri 15:22] \\
     No need to perform this - we have now a dedicated =AnnotationFilter= package for
     this.
 To integrate =ensembldb= with =Organism.dplyr= we export database tables in an
 /un-normalized/ form so that it can be stored into a SQLite database for =dplyr=.
** DONE Use =filters= as they are used in =Organism.dplyr=
   CLOSED: [2017-03-22 Wed 06:58]

   - State "DONE"       from "TODO"       [2017-03-22 Wed 06:58]
i.e. dynamically create filters. Check if we could do that.

#+BEGIN_SRC R
  library(Organism.dplyr)
  ## library(ensembldb)

  Tx_idFilter(value = 3, condition = "==")
  Tx_nameFilter(value = c("dfda", "sdfsd"))
#+END_SRC

Now, their filters are created /dynamically/, the first part of the name being the
attribute (field) name followed by /Filter/. How could I use these? Problem comes
since my attributes are not unique, i.e. present in one table only.

** DONE Implement a different type of filtering
   CLOSED: [2017-06-16 Fri 09:27]

   - State "DONE"       from "TODO"       [2017-06-16 Fri 09:27]
Implement a filtering that does allow calls like

#+BEGIN_EXAMPLE
  genes(filter(edb, GeneidFilter("a")))
#+END_EXAMPLE

This should also enable

#+BEGIN_EXAMPLE
  filter(edb, GeneidFilter(""a)) %>% genes()
#+END_EXAMPLE

The idea would be to add filter(s) as =AnnotationFilterList= object(s) to the
=EnsDb= object. Eventually by binding/adding it to the =.properties= slot. There are
even the =properties=, =getProperty=, =dropProperty= and =setProperty= methods (check
/Methods.R/.

Now, how should this function be called? =filter= would be intuitive, but is
already taken. What about BioGenerics =Filter=?

** DONE Interpret R logical conditions
   CLOSED: [2017-03-22 Wed 06:58]

   - State "DONE"       from "TODO"       [2017-03-22 Wed 06:58]
That would be the coolest thing ever, if we could use filters like

#+BEGIN_EXAMPLE
  genes(edb, filter = gene_id == "BCL2")
#+END_EXAMPLE

For simple things that would work, but it would be quite tricky to use
combinations, especially if they are enclosed in brackets!

I could basically
+ split by =&= and =|=.
+ split each of the resulting elements by the supported conditions.

Actually it would be better to replace first all =&= by =@&@=.

#+BEGIN_SRC R
  res <- quote(gene_id == "abc" & seq_name == "X")
  class(res)

  eval(res)

  as.character(res)
  ## Oh, interesting!

  myCall <- quote((gene_id == "a" | gene_id == "b") & seq_name == "Y")

  all.names(myCall)

  res <- as.character(myCall)
  res[1]
  res[2]
  res[3]
  ## hm, further split the second?
  as.character(parse(text = res[2]))  ## nope

  as.character(substitute(res[2]))
  class(substitute(gene_id == "a")) ## hm, similar to quote...

  deparse(res[[2]])
  res[2]
  parse(text = res[2]) ## OK, have an expression now.

  library(pryr)
  as.character(ast(gene_id == "abc"))

  as.symbol(res[2])

  c2 <- quote(gene_id %in% c(2, 3, 5))

  eval(parse(text = c2[3])) ## would have to eval c( and :

  c3 <- quote(gene_id %in% c(2, 3, 5) & (bbla > 5 | g < 5) & ggg == 3)
  res <- as.character(c3)

  quote(eval(parse(text = res[2])))
  parse(text = res[2])  ## It's an expression, need a call.
  (parse(text = res[2]))

  myE <- new.env()
  library(AnnotationFilter)
  myE$gene_id <- GeneIdFilter

  eval(3 == 3, envir = myE)
  myE$`==` <- function(x) {cat(x)}

  ## START HERE
  myL <- list()
  myL$`==` <- function(x, y) cat(as.character(quote(x)), " - ", y, "\n")

  myL$`&` <- function(a, b) {
      cat("----- & ----\n")
      cat("a: ", class(a), " ", a, "\n")
      cat("b: ", class(b), " ", b, "\n")
      cat("----- & DONE ----\n")
  }

  eval(quote(gene_id == 4), envir = myL)
  eval(quote(4 & 2), envir = myL)

  eval(quote(gene_id == 4 & 2), envir = myL)

  eval(quote(gene_id == 4 & other_id == 3), envir = myL)

  res <- quote(gene_id == "abc" & seq_name == "X")
  eval(res, envir = myL)

  secL <- list()
  secL$`==` <- function(x, y) cat(as.character(quote(x)), "==", eval(y))
  secL$`&` <- function(a, b) cat(a, "and", b)

  eval(res, envir = secL)

  thiL <- list()
  thiL$`==` <- function(x, y) paste0(as.character(quote(x)), " == ", eval(y))
  thiL$`==` <- function(x, y) {
      ## xName <- substitute(x)
      ## cat(length(xName))
      ## cat(class(xName))
      ## cat(xName)
      ## if (!is.null(fun <- get0(x, inherits = FALSE)))
      ##     cat("x", x , "found")
      ## else
      ##     cat("x", as.character(x), "not found")
      ## if (exists(x))
      do.call(x, list(y, "=="))
      ## cond <- " == "
      ## y <- paste0("'", eval(y), "'")
      ## if (length(y) > 1) {
      ##     y <- paste0("(", paste0(y, collapse = ","), ")")
      ##     cond <- " in "
      ## }
      ## paste0(as.character(quote(x)), cond, y)
  }
  thiL$gene_id <- function(val, cond) {
      val <- paste0("'", val, "'")
      if (length(val) > 1) {
          if (cond == "==")
              cond <- "in"
          val <- paste0("(", paste0(val, collapse = ","), ")")
      }
      return(paste("gene_id", cond, val))
  }
  thiL$seq_name <- function(val, cond) {
      val <- paste0("'", val, "'")
      if (length(val) > 1) {
          if (cond == "==")
              cond <- "in"
          val <- paste0("(", paste0(val, collapse = ","), ")")
      }
      return(paste("seq_name", cond, val))
  }
  thiL$`&` <- function(a, b) paste0(a, " and ", b)
  thiL$`>` <- function(a, b) {
      ## That's the only way I can check that this exists and is valid! not that
      ## we've got a variable defined somewhere.
      tryCatch(
          cat(is.function(a))
	, error = function(e) {
            stop("Nono, -", deparse(substitute(a)), "-", e)
	})
  }
  ## Have to extract the stuff from the error string!!!

  eval(quote(gene_id == "abc"), envir = thiL)

  eval(quote(gene_id == "abc" & seq_name == 1:3), envir = thiL)

  ## That's the point - how to catch if the key can not be found???
  eval(quote(bla_id == "adf"), envir = thiL)
  eval(quote(bla_id > 2), envir = thiL)
  eval(quote(gene_id > 2), envir = thiL)

  blu <- 3
  eval(quote(blu > 2), envir = thiL)

  tt <- function(a, b) {
      cat(as.character(a))
  }

  tt(quote(gene_id), 4)
#+END_SRC

OK, it /should/ work: bind a function to e.g. =gene_id= that is supposed to return
the result. Bind also a function to /==/, /&/ and all other possible operators, /&/
and /|/ just concatenating the elements, but /==/ calling the function bound to the
first passed argument. I can check for an existing column using the
=exists("gene_id")= function.


** DONE Ensure all depending packages work with =AnnotationFilter=
   CLOSED: [2017-05-16 Tue 06:24]

   - State "DONE"       from "TODO"       [2017-05-16 Tue 06:24]
+ [X] =biovizBase=: *has to be fixed*. Uses filter classes from =ensembldb=. Forked
  the repo from github mirror and fixed it in version 1.23.3 (i.e. import
  filters from =AnnotationFilter= instead.
+ [X] =Gviz=: OK if =biovizBase= is fixed.
+ [X] =ChIPpeakAnno=: OK if =biovizBase= is fixed.
+ [X] =Pbase=: *has to be fixed*.
+ [X] =TVTB=: added an issue to https://github.com/kevinrue/TVTB/issues/5. Just
  needs to import the filters from =AnnotationFilter= instead of =ensembldb=.
+ [X] =VariantFiltering=: OK once =biovizBase= builds. Probably due to that.
+ [X] =chimeraviz=: added an issue to
  https://github.com/stianlagstad/chimeraviz/issues/3. Just needs to import the
  =GeneIdFilter= from =AnnotationFilter= instead.
+ [X] =ggbio=: *has to be fixed*.

To fix it:
1) Install =AnnotationFilter=.
2) Disable the =Gviz= and =ggbio= vignette and (momentarily) remove =Gviz= suggestion
   (from DESCRIPTION and vignette depends).
3) Install/fix =biocvizBase=.
4) Install/fix =ggio=.
5) Install/fix =Pbase=.

The remaining packages (=Gviz=, =alpine=, =ChIPpeakAnno=).


Steps when =AnnotationFilter= is accepted:
+ [X] Contact Micheal Lawrence that =biovizBase= and =ggbio= should be fixed (have
  patches).
+ [X] Push new =ensembldb= package.
+ [X] Contact developers of =chimeraviz= and =TVTB= and =wiggleplotr=.

** DONE Fix/check packages failing to build for Bioc 3.5
   CLOSED: [2017-05-16 Tue 06:24]

   - State "DONE"       from "TODO"       [2017-05-16 Tue 06:24]
A
+ [ ] affycoretools: because of ReportingTools
+ [ ] AgiMicroRna: because of affycoretools
+ [X] AllelicImbalance: because of Gviz
+ [X] ASpli: because of Gviz

B
+ [ ] BgeeDB ? not related to ensembldb
+ [X] biomvRCNS: because of Gviz
+ [X] biovizBase: *depends* on ensembldb!!! Has been fixed. XXXX
+ [X] BubbleTree: because of biovizBase

C
+ [X] CAFE: because of biovizBase
+ [X] ChAMP: because of DMRcate
+ [X] Chicago: because of GenomicInteractions
+ [X] chimeraviz: *depends* on ensembldb!!! XXXX
+ [X] ChIPexoQual: depends on biovizBase
+ [X] ChIPpeakAnno: *depends* on ensembldb XXXX, but BUILDS.
+ [X] CINdex: depends on biovizBase.
+ [X] CNEr: depends on Gviz.
+ [X] coMET: depends on Gviz.
+ [X] compEpiTools: depends on methylPipe.
+ [X] cummeRbund: depends on Gviz.

D
+ [X] DeepBlueR: depends on Gviz.
+ [X] derfinder: depends on biovizBase.
+ [X] derfinderPlot: depends on derfinder, biovizBase
+ [X] DMRcate: depends on Gviz.
+ [X] DMRforPairs: depends on Gviz.

E
+ [ ] EnrichmentBrowser: depends on GSEABase.

F
+ [X] FourCSeq: depends on ggbio.

G
+ [X] GeneGeneInteR: depends on GGtools.
+ [X] GenomicInteractions: depends on Gviz.
+ [X] GGBase: depends on GGtools.
+ [X] ggbio: *depends* on ensembldb!!!! XXXX
+ [X] GGtools: depends on Gviz.
+ [X] GoogleGenomics: depends on ggbio.
+ [X] gQTLBase: depends on GGtools.
+ [ ] GSEABase: depends on ReportingTools.
+ [X] Gviz: depends on biovizBase.
+ [X] gwascat: depends on Gviz, ggbio.

H
I
+ [X] InPAS: depends on Gviz.
+ [X] intansv: depends on ggbio.

J

K
+ [X] karyoploteR: depends on biovizBase.

L
+ [X] ldblock: depends on gwascat.

M
+ [X] MEAL: depends on DMRcate.
+ [X] meshr: depends on cummeRbund.
+ [X] methyAnalysis: depends on Gviz.
+ [X] methylPipe: depends on Gviz.
+ [X] motifbreakR: depends on Gviz.

N
+ [X] NADfinder: depends on trackViewer.

P
+ [ ] Pbase: *depends* on ensembldb!!! XXXX Fixed/not fixed.
+ [X] pepStat: depends on Pviz.
+ [X] Pi: depends on ggbio.
+ [X] PING: depends on Gviz.
+ [X] pqsfinder: depends on Gviz. -> biomaRt error.
+ [X] Pviz: depends on Gviz.

Q
+ [X] qrqc: depends on biovizBase.
+ [X] QuasR: depends on Gviz.

R
+ [X] R3CPET: depends on ggbio.
+ [X] RareVariantVis: depends on VariantFiltering.
+ [X] Rariant: depends on ggbio.
+ [ ] ReportingTools: depends on ggbio. PFAM.db not available.
+ [X] RiboProfiling: depends on ggbio
+ [X] Rqc: depends on biovizBase.

S
+ [X] SomaticSignatures: depends on ggbio.
+ [X] spliceR: depends on cummeRbund.
+ [X] SplicingGraphs: depends on Gviz.
+ [X] SPLINTER: depends on Gviz.
+ [X] STAN: depends on Gviz.

T
+ [X] trackViewer: depends on Gviz.

V
+ [X] VariantFiltering: depends on Gviz.
+ [X] vtpnet: depends on gwascat.

W
+ [ ] wiggleplotr: *depends* on ensembldb!!!! XXXX

Y
+ [X] YAPSA: depends on SomaticSignatures.


Base on =ensembldb=:
+ [X] =biovizBase=:
+ [X] =chimeraviz=:
+ [X] =ChIPpeakAnno=:
+ [X] =ggbio=:
+ [ ] =Pbase=:
+ [ ] =wiggleplotr=:
** DONE entrezid in separate database table
   CLOSED: [2017-06-16 Fri 09:27]

   - State "DONE"       from "TODO"       [2017-06-16 Fri 09:27]
+ [X] Perl script to save =entrezid= into a separate table =entrezgene=.
+ [X] Import script to create the additional table and indices (=gene_id= and
  =entrezid=).
+ [X] Concatenate on SQL levels? =group_concat(X,Y)=. NO! Return the result as a
  list.
+ [X] Test if queries work for genes that don't have an entry in =entrezid=,
  otherwise save just the =gene_id= into the table without =entrezid=. Using a =left
  outer join= seems to fix that.
+ [X] Different SQL queries depending on DBSCHEMA version: extract the
  DBSCHEMAVERSION using the =dbSchemaVersion= function (passing the =EnsDb=). Seems
  to work out of the box - no need to make schema dependent calls.

+ [X] Put =entrezid= as a =list= into =GRanges=? The point is we have to collapse the
  entries we have to specify by what. E.g. by =gene_id= if the call is =genes=, by
  =exon_id= if the call is =exons= or =exonsBy= etc. WORKS.
+ [X] Validity dependent on DB schema.
+ [ ] Build from GRanges: use database version 2.0 schema?
+ [X] Update documentation: mention that column entrezid is a =list=.
+ [X] Update vignette: mention that column entrezid is a =list= and update the
  database layout.
+ [X] Fix =select=.
+ [X] Fix =mapIds=.
+ [X] Check the package on the database with DBSCHEMAVERSION 1.0.
+ [X] Check the package on the database with DBSCHEMAVERSION 2.0.


Some test code below.
#+BEGIN_SRC R :eval never
  library(ensembldb)
  library(testthat)

  edb <- EnsDb("/Users/jo/tmp/ensdb_20/EnsDb.Hsapiens.v88.sqlite")

  ensembldb:::dbSchemaVersion(edb)

  system.time(gns1 <- genes(edb, return.type = "data.frame")) ## 0.677 sec
  system.time(gns2 <- genes(edb, return.type = "data.frame",
			    columns = c(listColumns(edb, "gene"), "entrezid"))) ## 1.5

  all(unique(gns1$gene_id) == unique(gns2$gene_id))
  expect_equal(gns1$gene_id, gns2$gene_id)

  ## Seems to work...
  gns2 <- genes(edb, columns = c(listColumns(edb, "gene"), "entrezid"))

  ## Check for transcripts
  ## transcripts
  system.time(tx1 <- transcripts(edb))  ## 3.2 sec
  system.time(tx2 <- transcripts(
		  edb, columns = c(listColumns(edb, "tx"), "entrezid")))  ## 5.5
  expect_equal(length(tx1), length(tx2))
  expect_equal(mcols(tx1), mcols(tx2)[, -ncol(mcols(tx2))])
  expect_equal(names(tx1), names(tx2))

  ## transcriptsBy
  tx1 <- transcriptsBy(edb)
  tx2 <- transcriptsBy(edb, columns = c(listColumns(edb, "tx"), "entrezid"))
  expect_equal(length(tx1), length(tx2))
  expect_equal(mcols(tx1), mcols(tx2)[, -ncol(mcols(tx2))])
  expect_equal(names(tx1), names(tx2))


  ## Check for exons
  ## exons
  ex1 <- exons(edb)
  ex2 <- exons(edb, columns = c(listColumns(edb, "exon"), "entrezid"))
  expect_equal(length(ex1), length(ex2))
  expect_equal(names(ex1), names(ex2))
  ## Are all entrezids unique?
  lens <- lengths(ex2$entrezid)
  lens_2 <- lengths(lapply(ex2$entrezid, unique))
  expect_equal(lens, lens_2)

  ## exonsBy
  ex1 <- exonsBy(edb)
  ex2 <- exonsBy(edb, columns = c(listColumns(edb, "exon"), "entrezid"))
  all.equal(names(ex1), names(ex2))
  expect_equal(length(ex1), length(ex2))
  expect_equal(mcols(ex1), mcols(ex2)[, -ncol(mcols(ex2))])

  ## cdsBy
  cs1 <- cdsBy(edb)
  cs2 <- cdsBy(edb, columns = c("entrezid"))
  all.equal(names(cs1), names(cs2))
  expect_equal(length(cs1), length(cs2))
  expect_equal(mcols(cs1), mcols(cs2)[, -1])

  ## threeUTRsByTranscript
  tu1 <- threeUTRsByTranscript(edb)
  tu2 <- threeUTRsByTranscript(edb, columns = "entrezid")
  all.equal(names(tu1), names(tu2))
  expect_equal(length(tu1), length(tu2))
  expect_equal(mcols(tu1), mcols(tu2)[, -1])
  ## fiveUTRsByTranscript
  fu1 <- fiveUTRsByTranscript(edb)
  fu2 <- fiveUTRsByTranscript(edb, columns = "entrezid")
  all.equal(names(fu1), names(fu2))
  expect_equal(length(fu1), length(fu2))
  expect_equal(mcols(fu1), mcols(fu2)[, -1])

  ## proteins
  pr1 <- proteins(edb)
  pr2 <- proteins(edb, columns = c(listColumns(edb, "protein"), "entrezid"))
  all.equal(pr1$protein_id, pr2$protein_id)
  expect_equal(pr1, pr2[, -ncol(pr2)])


  tmp <- ensembldb:::getWhat(edb, columns = c(listColumns(edb, "gene"), "entrezid"))

  system.time(tmp_u <- unique(tmp[, -ncol(tmp)]))  ## 0.194

  system.time(tmp_1 <- .collapseEntrezidInTable(tmp, by = "gene_id"))
  system.time(tmp_2 <- ensembldb:::.collapseEntrezidInTable(tmp, by = "gene_id"))

  expect_equal(tmp_1, tmp_2)


  ## Check if we could do it faster...
  system.time(ids <- apply(tmp[, -ncol(tmp)], MARGIN = 1, FUN = paste0, collapse = ""))

  system.time(egs <- split(tmp$entrezid,
			   f = factor(tmp$gene_id, levels = unique(tmp$gene_id))))  ## 0.019
  system.time(egs <- lapply(egs, unique))  ## 0.6

  system.time(eg2 <- aggregate(tmp$entrezid,
			       by = list(factor(tmp$gene_id,
					   levels = unique(tmp$gene_id))),
			       FUN = unique))

  system.time(tmp <- unique(gns2[, colnames(gns2) != "entrezid"]))  ## 0.201

  system.time(tmp2 <- gns2[match(names(egs), gns2$gene_id), ])  ## 0.029

  all.equal(tmp, tmp2[, -ncol(tmp2)])

  DF <- DataFrame(tmp2)
  DF$entrezid <- egs

  system.time(Test <- .collapseEntrezidInTable(gns2))  ## 0.05
#+END_SRC

Testing select etc methods:
#+BEGIN_SRC R
  library(ensembldb)
  library(testthat)

  edb <- EnsDb("/Users/jo/tmp/ensdb_20/EnsDb.Hsapiens.v88.sqlite")

  all <- select(edb) ## THAT SHOULD WORK!
  all <- select(edb, keys = ~ symbol == "BCL2")

  gns <- genes(edb)

  ## Gene with multiple entrezgenes
  all <- select(edb, keys = ~ symbol == "DDX11L1")

  all_u <- unique(all[, -1])
  n_entrez <- length(unique(all[, 1]))
  ## Expect that the nrow of 'all' is:
  expect_equal(nrow(all_u) * n_entrez, nrow(all))

  ## Looks OK.
  vals <- mapIds(edb, keys = "DDX11L1", column = "ENTREZID", keytype = "SYMBOL",
		 multiVals = "list")
  expect_equal(length(vals[[1]]), n_entrez)

  ## Seems to work...
  vals <- mapIds(edb, keys = ~ symbol %in% c("BCL2", "DDX11L1", "ZBTB16"),
		 column = "ENTREZID", multiVals = "list")
  vals

#+END_SRC

Seems to work out of the box...

** TODO Add functionality to map protein coords to genomic coords

+ Given: protein ID, coordinates within protein.
1) Map protein coords to coords within transcript.
2) Map within transcript coords to exon and genome coords.
Result: GRanges with genomic start/end coords (eventually more if over splice
junctions).

The test object: ENSP00000269305, 281, 391

+ [ ] For each protein, fetch also its sequence and compare the length(s) of the
  corresponding CDS(s) with its length and select the best matching CDS. If the
  length does not perfectly match, show a warning that CDS and protein sequence
  length do not macht for XXX, thus returned genomic coordinates might not be
  OK. The code in =Pbase= contains an example tx.

+ [ ] =proteinToTranscript=: map within protein coordinates to within transcript
  coordinates. Same concept as with =proteinToGenome=, but return the coordinates
  relative to the (reported) TSS of the tx.

+ [ ] =genomeToTranscript=: see below, but one step less.

+ [ ] =genomeToProtein=: ? is this not something we can already do?
  - For the genomic coords, get the exons there (using a =GRangesFilter=).
  - Calculate the coordinates relative within the protein.

** TODO Fix / adjust coordinate mapping for proteins without matching CDS

Align RNA and AA sequence, trim AA sequence and adjust the within-AA position.
